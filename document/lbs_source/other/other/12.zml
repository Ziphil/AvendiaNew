\zml?|version="1.0"|>
\xml?|version="1.0",encoding="UTF-8"|>

\page<
  \name<ポイントフリー Haskell メモ>

  \h1<概要>
  \p<
    Haskell における関数の定義方法として、ポイントフリースタイルというものがあります。
    これは、仮引数を使わずに関数適用と合成だけで関数を定義するスタイルのことで、こちらの方がより簡潔に分かりやすいコードになることがあります。
    このページには、仮引数を使った関数定義をポイントフリースタイルに書き換えるときに使えそうなテクニックをまとめてあります。
  >
  \p<
    なお、ポイントフリースタイルにすることでかえって式が煩雑になることも多いです。
    このページに記載したテクニックは、ポイントフリースタイルでより見やすくなるであろうパターンのみに絞っています。
  >
  \p<
    各項目において、コードの 1 行目が仮引数による定義で、2 行目以降がそれをポイントフリースタイルに書き換えた定義です。
    概ね、以下のように関数名や変数名を使い分けています。
  >
  \ul<
    \li<\m<hoge> ･･･ そこで定義する関数>
    \li<\m<x>, \m<y>, \m<z> ･･･ 仮引数 (これを消したい)>
    \li<\m<f>, \m<g>, \m<h> ･･･ すでに別の場所で定義されている関数>
    \li<\m<s>, \m<t>, \m<u> ･･･ すでに別の場所で定義されている定数>
    \li<\m~<#> ･･･ すでに別の場所で定義されている演算子>
  >
  \h1<関数合成の応用>
  \h2<合成の基本>
  \pre~<
    hoge x = g (f x)
    hoge = g . f
  >
  \p<
    全ての基本。
    引数に順に関数を適用する場合は、関数合成の演算子である \m<.> を用いることができる。
  >
  \h2<合成する最初の関数が 2 引数以上の場合>
  \pre~<
    hoge x y = g (f x y)
    hoge = (g .) . f
  >
  \p<
    合成する関数がともに 1 引数なら上のように \m<.> で繋げれば良いが、合成する最初の関数が 2 引数の場合は少し複雑になる。
  >
  \pre~<
    hoge x y = g (x # y)
    hoge = (g .) . (#)
  >
  \p<
    このパターンは \m<f> が演算子の場合も多そう。
  >
  \pre~<
    hoge x y z = g (f x y z)
    hoge = ((g .) .) . f
  >
  \p<
    最初の関数が 3 引数の場合はこうなる。
    4 引数以上の場合がどうなるかは省略するが、括弧と \m<.> が増えるだけである。
  >
  \h1<引数を複数回使うもの>
  \h2<2 つの関数をそれぞれ適用したものをさらに関数に適用する>
  \pre~<
    hoge x = f (g x) (h x)
    hoge = liftA2 f g h
  >
  \p<
    1 つの引数に対して 2 つの関数を別々に適用し、それらの結果を別の 2 引数関数に渡す場合、このように \a|href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:liftA2",target="_blank"|<\m<liftA2>> が利用できる。
    本来この関数は、普通の二項演算を \m<Applicative> の文脈の二項演算に持ち上げるための関数だが、ここでは \m<(-`>) r> が \m<Applicative> のインスタンスであることを利用して、\m<(a -`> b -`> c) -`> (r -`> a) -`> (r -`> b) -`> (r -`> c)> 型の関数として用いている。
  >
  \pre~<
    hoge x = (g x, h x)
    hoge = liftA2 (,) g h
    hoge = g &&& h
  >
  \p<
    特に \m<f> がタプルを構成する \m<(,)> の場合は、\c<liftA2 (,)> と書いても良いが、\a|href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Arrow.html#v:-38--38--38-",target="_blank"|<\m~<&&&>> を使うとさらに簡潔になる。 
  >
  \h2<タプルの要素それぞれに関数を適用する>
  \pre~<
    hoge (x, y) = (f x, g y)
    hoge = f *** g 
  >
  \p<
    タプルの左右それぞれの要素に別々の関数を適用して、その結果から成る新たなタプルを得ることについては、まさにその用途のための \a|href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Arrow.html#v:-42--42--42-",target="_blank"|<\m<***>> がある。
  >
  \h2<1 つの引数を複製して渡す>
  \pre~<
    hoge x = f x x
    hoge = join f
  >
  \p<
    1 つの引数を複製して 2 引数関数に渡す場合、\a|href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:join",target="_blank"|<\m<join>> が利用できる。
    この関数は二重のモナドを一重にするもので、ここでは \m<(-`>) r> が \m<Monad> のインスタンスであることを利用して、\m<(r -`> r -`> a) -`> (r -`> a)> 型の関数として用いている。
  >
  \pre~<
    hoge x = f x x x
    hoge = join (join f)
  >
  \p<
    3 つにコピーしたいなら \m<join> を繋げれば良い。
  >

>
